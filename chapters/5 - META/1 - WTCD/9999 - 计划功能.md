[评论](https://github.com/SCLeoX/Wearable-Technology/issues/74)

# 计划功能
WTCD 目前还在开发初期阶段，因此还有许多功能被计划实现但是还没有实现。这里给出目前计划中的功能。需要注意的是，具体的语法还没有确定，这里给出的只是目前的想法

## 函数
WTCD 的函数将会完全使用支持引用闭包的匿名函数。定义格式大概如下：

```wtcd
declare [
  function square = function [ number a ] {
    return a * a
  }
]
```

并且有语法糖：

```wtcd
declare function square[number a] a * a 
```

因为 WTCD 没有分隔符，非常遗憾，函数调用可能必须得写成：

```wtcd
result = square::[20] // 400
```

不过，这个可能可以用 pipeline operator `|>` 来化简：

```wtcd
result = 20 |> square
```

因为函数都是匿名的了，因此可能需要一个特殊语法来实现递归。目前的思路是使用 `::` 代表自身：

```wtcd
declare function factorial[number a] a == 1 ? 1 : a * ::[a - 1]
```

当然如果这个不实现也可以通过将声明和初始化分开的方法实现递归：

```wtcd
declare function factorial
factorial = function[number a] a == 1 ? 1 : a * factorial::[a - 1]
```

此外，函数将会支持引用闭包：

```wtcd
declare function makeCounter[] {
  declare number n = 0
  return function[] {
    n += 1
    return n
  }
}
```

使用例子：

```wtcd
declare [
  function counter1 = makeCounter::[]
  function counter2 = makeCounter::[]
]
counter1::[] // 1
counter1::[] // 2
counter1::[] // 3
counter2::[] // 1
counter1::[] // 4
counter2::[] // 2
```

## 列表
目前 WTCD 的所有的列表都是语法级别的特殊处理。但是未来计划实现允许存储值的有序列表。

```wtcd
declare [
  list number someNumberList = [ 1 2 3 ]
  list mixed someAnyList = [ 1 false 5 ]
]
```

如果实现列表，那么意味着 `spread` 也要实现了：

```wtcd
declare [
  list number innerList = [ 4 5 6 ]
  list number outerList = [ 1 2 3 ...innerList 7 8 9 ]
]
```

或者

```wtcd
declare [
  list choice choiceList = [
    choice "A" goto a
    choice "B" goto b
  ]
]

section main then selection [
  ...choiceList
  choice "C" goto c
]
```

## 标准库
标准库将会提供一些工具函数。举个例子获得一个字符串的长度：

```wtcd
declare number length = strlen::["Hello"] // 5
```

当然这个可以用 pipeline 来写：

```wtcd
declare number length = "Hello" |> strlen // 5
```

具体标准库会有哪些功能还是待定内容，但是可以期待会包含基本需要的字符串/列表操作。

## 引用赋值与引用比较
这个实现起来并不复杂，但是因为在设计初期没有考虑这个，所以不知道会不会影响什么别的功能。引用赋值大概是说让两个变量变成同一个东西。

举个例子：

```wtcd
declare [
  number a = 100
  number b
]
b =& a // 将 a 的引用给 b

a = 200
a // 200
b // 200

b = 300
a // 300
b // 300
```

因为没有想到什么好的方法可以解除引用，所以目前看来引用赋值是永久的...

类似的，引用比较可以判断两个变量是否是同一个引用。

```
declare [
  number a = 100
  number b = 100
]

a ==& b // false

a =& b

a ==& b // true
```
